import{l as I}from"./wagmiConfig.Chk1Y_fx.js";async function S(t,n){let e;if(typeof n.connector=="function"?e=t._internal.connectors.setup(n.connector):e=n.connector,e.uid===t.state.current)throw new I;try{t.setState(s=>({...s,status:"connecting"})),e.emitter.emit("message",{type:"connecting"});const o=await e.connect({chainId:n.chainId}),r=o.accounts;return e.emitter.off("connect",t._internal.events.connect),e.emitter.on("change",t._internal.events.change),e.emitter.on("disconnect",t._internal.events.disconnect),await t.storage?.setItem("recentConnectorId",e.id),t.setState(s=>({...s,connections:new Map(s.connections).set(e.uid,{accounts:r,chainId:o.chainId,connector:e}),current:e.uid,status:"connected"})),{accounts:r,chainId:o.chainId}}catch(o){throw t.setState(r=>({...r,status:r.current?"connected":"disconnected"})),o}}function l(t,n){if(t===n)return!0;if(t&&n&&typeof t=="object"&&typeof n=="object"){if(t.constructor!==n.constructor)return!1;let e,o;if(Array.isArray(t)&&Array.isArray(n)){if(e=t.length,e!==n.length)return!1;for(o=e;o--!==0;)if(!l(t[o],n[o]))return!1;return!0}if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();const r=Object.keys(t);if(e=r.length,e!==Object.keys(n).length)return!1;for(o=e;o--!==0;)if(!Object.prototype.hasOwnProperty.call(n,r[o]))return!1;for(o=e;o--!==0;){const s=r[o];if(s&&!l(t[s],n[s]))return!1}return!0}return t!==t&&n!==n}let f=[];function g(t){const n=[...t.state.connections.values()];return t.state.status==="reconnecting"||l(f,n)?f:(f=n,n)}let h=[];function m(t){const n=t.connectors;return l(h,n)?h:(h=n,n)}let p=!1;async function _(t,n={}){if(p)return[];p=!0,t.setState(c=>({...c,status:c.current?"reconnecting":"connecting"}));const e=[];if(n.connectors?.length)for(const c of n.connectors){let i;typeof c=="function"?i=t._internal.connectors.setup(c):i=c,e.push(i)}else e.push(...t.connectors);let o;try{o=await t.storage?.getItem("recentConnectorId")}catch{}const r={};for(const[,c]of t.state.connections)r[c.connector.id]=1;o&&(r[o]=0);const s=Object.keys(r).length>0?[...e].sort((c,i)=>(r[c.id]??10)-(r[i.id]??10)):e;let d=!1;const y=[],v=[];for(const c of s){const i=await c.getProvider().catch(()=>{});if(!i||v.some(a=>a===i)||!await c.isAuthorized())continue;const u=await c.connect({isReconnecting:!0}).catch(()=>null);u&&(c.emitter.off("connect",t._internal.events.connect),c.emitter.on("change",t._internal.events.change),c.emitter.on("disconnect",t._internal.events.disconnect),t.setState(a=>{const w=new Map(d?a.connections:new Map).set(c.uid,{accounts:u.accounts,chainId:u.chainId,connector:c});return{...a,current:d?a.current:c.uid,connections:w}}),y.push({accounts:u.accounts,chainId:u.chainId,connector:c}),v.push(i),d=!0)}return(t.state.status==="reconnecting"||t.state.status==="connecting")&&(d?t.setState(c=>({...c,status:"connected"})):t.setState(c=>({...c,connections:new Map,current:null,status:"disconnected"}))),p=!1,y}function j(t,n){const{onChange:e}=n;return t.subscribe(()=>g(t),e,{equalityFn:l})}export{S as c,m as g,_ as r,j as w};
