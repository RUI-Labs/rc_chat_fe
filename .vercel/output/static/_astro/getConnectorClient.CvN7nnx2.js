import{B as l,s as w,t as f,p as i,b as y,C as g,d as p,e as A,f as I,j as m}from"./wagmiConfig.Chk1Y_fx.js";class b extends l{constructor({docsPath:n}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."].join(`
`),{docsPath:n,docsSlug:"account"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AccountNotFoundError"})}}async function x(o,{account:n=o.account,message:t}){if(!n)throw new b({docsPath:"/docs/actions/wallet/signMessage"});const e=i(n);if(e.type==="local")return e.signMessage({message:t});const c=typeof t=="string"?w(t):t.raw instanceof Uint8Array?f(t.raw):t.raw;return o.request({method:"personal_sign",params:[c,e.address]},{retryCount:0})}function E(o,n={}){const{key:t="custom",name:e="Custom Provider",retryDelay:c}=n;return({retryCount:s})=>y({key:t,name:e,request:o.request.bind(o),retryCount:n.retryCount??s,retryDelay:c,type:"custom"})}async function v(o,n={}){let t;if(n.connector){const{connector:r}=n,[h,C]=await Promise.all([r.getAccounts(),r.getChainId()]);t={accounts:h,chainId:C,connector:r}}else t=o.state.connections.get(o.state.current);if(!t)throw new g;const e=n.chainId??t.chainId,c=await t.connector.getChainId();if(c!==t.chainId)throw new p({connectionChainId:t.chainId,connectorChainId:c});const s=t.connector;if(s.getClient)return s.getClient({chainId:e});const a=i(n.account??t.accounts[0]);a.address=A(a.address);const u=o.chains.find(r=>r.id===e),d=await t.connector.getProvider({chainId:e});if(n.account&&!t.accounts.some(r=>r.toLowerCase()===a.address.toLowerCase()))throw new I({address:a.address,connector:s});return m({account:a,chain:u,name:"Connector Client",transport:r=>E(d)({...r,retryCount:0})})}export{b as A,v as g,x as s};
